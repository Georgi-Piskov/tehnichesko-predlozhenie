{
  "name": "TP - Step 6: Validate Document",
  "nodes": [
    {
      "id": "trigger",
      "name": "Start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [0, 300],
      "parameters": {
        "inputSource": "passthrough"
      },
      "typeVersion": 1.1
    },
    {
      "id": "completeness_llm",
      "name": "Check Completeness",
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "position": [300, 160],
      "parameters": {
        "text": "=Ти си одитор на технически предложения за обществени поръчки.\n\nПроверяваш дали ВСЯКО изискване от документацията е адресирано в текста.\n\nИЗИСКВАНИЯ ОТ ДОКУМЕНТАЦИЯТА:\n{{ JSON.stringify($json.requirements, null, 2).substring(0, 30000) }}\n\nНАПИСАН ТЕКСТ (проверяван):\n{{ $json.draftText.substring(0, 60000) }}\n\nЗа ВСЯКО изискване провери:\n1. Присъства ли в текста?\n2. Достатъчно подробно ли е?\n3. Конкретно ли е за проекта?\n4. Всички ли аспекти са покрити?\n\nВърни САМО JSON:\n{\n  \"overall_verdict\": \"PASS или FAIL\",\n  \"coverage_score\": 0-100,\n  \"checks\": [\n    {\n      \"requirement_id\": \"1.1\",\n      \"status\": \"PASS или FAIL или PARTIAL\",\n      \"issues\": [\"описание на проблем\"],\n      \"missing_content\": \"какво липсва\"\n    }\n  ],\n  \"critical_gaps\": [\"критични пропуски\"],\n  \"rewrite_instructions\": \"инструкции за корекция ако FAIL\"\n}",
        "promptType": "define",
        "messages": {
          "messageValues": [
            {
              "type": "system",
              "message": "You are a strict quality auditor for Bulgarian procurement proposals. ZERO TOLERANCE for missing requirements. Output ONLY valid JSON. Language: Bulgarian."
            }
          ]
        }
      },
      "typeVersion": 1.4
    },
    {
      "id": "completeness_model",
      "name": "Claude Opus (Completeness)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [220, 380],
      "parameters": {
        "model": "anthropic/claude-opus-4-20250514",
        "options": {
          "baseURL": "https://openrouter.ai/api/v1",
          "maxTokens": 8000,
          "temperature": 0.1
        }
      },
      "typeVersion": 1
    },
    {
      "id": "relevance_llm",
      "name": "Check Relevance",
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "position": [300, 560],
      "parameters": {
        "text": "=Ти си специалист по оценка на технически предложения.\n\nТвоята ЕДИНСТВЕНА задача: намери текст, който е:\n- Твърде общ (приложим за всяка поръчка)\n- Нерелевантен за конкретната поръчка\n- Copy-paste шаблон\n- Фактически несъответстващ на спецификацията\n\nТЕХНИЧЕСКА СПЕЦИФИКАЦИЯ:\n{{ JSON.stringify($json.specData, null, 2).substring(0, 20000) }}\n\nНАПИСАН ТЕКСТ:\n{{ $json.draftText.substring(0, 60000) }}\n\nВърни САМО JSON:\n{\n  \"overall_verdict\": \"PASS или FAIL\",\n  \"relevance_score\": 0-100,\n  \"flagged_paragraphs\": [\n    {\n      \"paragraph_number\": 1,\n      \"issue_type\": \"GENERIC или IRRELEVANT или INCONSISTENT или BOILERPLATE\",\n      \"explanation\": \"защо е маркиран\",\n      \"suggestion\": \"как да се поправи\"\n    }\n  ],\n  \"consistency_issues\": [\n    {\n      \"text_says\": \"какво пише\",\n      \"spec_says\": \"какво е в спецификацията\",\n      \"resolution\": \"как да се оправи\"\n    }\n  ],\n  \"rewrite_instructions\": \"инструкции ако FAIL\"\n}",
        "promptType": "define",
        "messages": {
          "messageValues": [
            {
              "type": "system",
              "message": "You evaluate technical proposals for relevance and specificity. Flag generic, boilerplate, or inconsistent content. Output ONLY valid JSON. Language: Bulgarian."
            }
          ]
        }
      },
      "typeVersion": 1.4
    },
    {
      "id": "relevance_model",
      "name": "Gemini Pro (Relevance)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [220, 780],
      "parameters": {
        "model": "google/gemini-2.5-pro",
        "options": {
          "baseURL": "https://openrouter.ai/api/v1",
          "maxTokens": 8000,
          "temperature": 0.1
        }
      },
      "typeVersion": 1
    },
    {
      "id": "parse_completeness",
      "name": "Parse Completeness",
      "type": "n8n-nodes-base.code",
      "position": [600, 160],
      "parameters": {
        "jsCode": "const raw = ($json.text || $json.response || '').trim();\nlet result;\ntry {\n  result = JSON.parse(raw);\n} catch (e) {\n  const m = raw.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n  const candidate = m ? m[1].trim() : raw;\n  try {\n    const s = candidate.indexOf('{');\n    const e2 = candidate.lastIndexOf('}');\n    let js = candidate.substring(s, e2 + 1).replace(/,\\s*([\\]\\}])/g, '$1');\n    result = JSON.parse(js);\n  } catch (e3) {\n    result = { overall_verdict: 'ERROR', coverage_score: 0, checks: [], critical_gaps: ['Parse error'], _raw: raw.substring(0, 1000) };\n  }\n}\nreturn [{ json: { completenessResult: result } }];"
      },
      "typeVersion": 2
    },
    {
      "id": "parse_relevance",
      "name": "Parse Relevance",
      "type": "n8n-nodes-base.code",
      "position": [600, 560],
      "parameters": {
        "jsCode": "const raw = ($json.text || $json.response || '').trim();\nlet result;\ntry {\n  result = JSON.parse(raw);\n} catch (e) {\n  const m = raw.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n  const candidate = m ? m[1].trim() : raw;\n  try {\n    const s = candidate.indexOf('{');\n    const e2 = candidate.lastIndexOf('}');\n    let js = candidate.substring(s, e2 + 1).replace(/,\\s*([\\]\\}])/g, '$1');\n    result = JSON.parse(js);\n  } catch (e3) {\n    result = { overall_verdict: 'ERROR', relevance_score: 0, flagged_paragraphs: [], _raw: raw.substring(0, 1000) };\n  }\n}\nreturn [{ json: { relevanceResult: result } }];"
      },
      "typeVersion": 2
    },
    {
      "id": "merge",
      "name": "Merge Results",
      "type": "n8n-nodes-base.code",
      "position": [900, 360],
      "parameters": {
        "jsCode": "const items = $input.all();\nconst completeness = items.find(i => i.json.completenessResult)?.json?.completenessResult || {};\nconst relevance = items.find(i => i.json.relevanceResult)?.json?.relevanceResult || {};\n\nconst passed = (completeness.overall_verdict === 'PASS') && (relevance.overall_verdict === 'PASS');\n\nlet rewriteInstructions = '';\nif (!passed) {\n  const parts = [];\n  if (completeness.overall_verdict !== 'PASS') {\n    parts.push('ПРОПУСКИ В ПОКРИТИЕТО:');\n    if (completeness.critical_gaps) parts.push(completeness.critical_gaps.join('; '));\n    if (completeness.rewrite_instructions) parts.push(completeness.rewrite_instructions);\n  }\n  if (relevance.overall_verdict !== 'PASS') {\n    parts.push('ПРОБЛЕМИ С РЕЛЕВАНТНОСТТА:');\n    if (relevance.rewrite_instructions) parts.push(relevance.rewrite_instructions);\n    if (relevance.consistency_issues) {\n      for (const ci of relevance.consistency_issues) {\n        parts.push(`Текстът казва: ${ci.text_says} | Спец. казва: ${ci.spec_says} | Решение: ${ci.resolution}`);\n      }\n    }\n  }\n  rewriteInstructions = parts.join('\\n');\n}\n\nreturn [{\n  json: {\n    validationPassed: passed,\n    completenessResult: completeness,\n    relevanceResult: relevance,\n    coverageScore: completeness.coverage_score || 0,\n    relevanceScore: relevance.relevance_score || 0,\n    rewriteInstructions\n  }\n}];"
      },
      "typeVersion": 2
    }
  ],
  "connections": {
    "Start": {
      "main": [
        [
          { "node": "Check Completeness", "type": "main", "index": 0 },
          { "node": "Check Relevance", "type": "main", "index": 0 }
        ]
      ]
    },
    "Claude Opus (Completeness)": { "ai_languageModel": [[{ "node": "Check Completeness", "type": "ai_languageModel", "index": 0 }]] },
    "Gemini Pro (Relevance)": { "ai_languageModel": [[{ "node": "Check Relevance", "type": "ai_languageModel", "index": 0 }]] },
    "Check Completeness": { "main": [[{ "node": "Parse Completeness", "type": "main", "index": 0 }]] },
    "Check Relevance": { "main": [[{ "node": "Parse Relevance", "type": "main", "index": 0 }]] },
    "Parse Completeness": { "main": [[{ "node": "Merge Results", "type": "main", "index": 0 }]] },
    "Parse Relevance": { "main": [[{ "node": "Merge Results", "type": "main", "index": 0 }]] }
  },
  "settings": { "executionOrder": "v1" }
}
